# Реализация биржевого стакана.

Биржевой стакан реализован в виде класса. Сам класс является частью библиотеки.
Это сделано для упрощения тестирования и сопровождения.
В качестве системы сборки используется ```CMake```.

## Пояснение структуры библиотеки:

Заголовочные файлы (```.hpp```), используемые пользователями, вынесены в
папку ```include``` (все то, что подключает пользователь).
Внутренние заголовочные файлы, недоступные пользователю, и ```.cpp``` файлы
содержатся в папке ```src```.

Я реализовал две версии биржевого стакана. Они отличаются используемыми
алгоритмами, однако имеют одинаковый интерфейс.
Обе реализации являются
наследниками базового класса  ```IOrderBook```. Данное архитектурное решение
делает реализации классов взаимозаменяемыми и позволяет использовать инъекцию
зависимостей (она используется при тестировании).

## Решение задачи 1 (класс UnlimitedOrderBook a.k.a OrderBook):

Класс биржевого стакана должен уметь быстро обрабатывать ряд запросов, а именно:

* Добавление новой заявки
* Удаление заявки (удалена может быть любая заявка)
* Изменение имеющейся заявки (изменена может быть любая заявка)
* Вывод 10-ти лучших заявок.

Заявка представляет собой структуру, содержащую информацию о:

* Цене
* Объеме
* Типе (Bid/Ask)

Исходя из структуры заявки мы можем менять любое ее поле. При изменении цены или
типа, заявка меняет свое положение в стакане.

В коде заявка представлена в виде следующей структуры:

```c++ 
using Currency = std::uint64_t; // in cents

using Amount = std::uint64_t;

struct Order {
	enum class Type {
		ASK = 0,
		BID = 1,
	};
	Type type;
	Currency price;
	Amount amount;
};
```

### Обоснование структуры стакана:

Так как нам нужно поддерживать динамические и частые изменения содержимого
стакана
, то необходимо использовать структуры данных, позволяющие быстро удалять, и
изменять содержащиеся в них произвольные элементы.

Подобными свойствами обладают контейнеры:

* ```std::map``` - O(logN)
* ```std::list``` - O(1)
* ```std::set``` - O(logN)
* ```std::unordered_map``` - амортизированная O(1)
* ```std::unordered_set``` - амортизированная O(1)

Будем хранить заявки в ```std::map```, отсортированными по цене (цена заявки -
ключ), согласно типу.
```Bid```-заявки сортируем по убыванию. ```Ask```- по возрастанию.
Значением словаря будет ```std::list```, содержащий заявки.
Выбор ```std::list``` обусловлен необходимостью удаления произвольных элементов.
Мы не можем использовать контейнер ```std::vector```, так как удаление из
середины повлечет
за собой перемещение элементов, а добавление новых элементов вызовет инвалидацию
итераторов.
Связный список нам подходит лучше, так как вставка и удаление произвольного
элемента работает за ```O(1)```.

### Обеспечим доступ к заявкам в стакане за O(logN):

При добавлении заявки определим нужный ей словарь. Добавим заявку в конец списка
для конкретной цены. А затем, сгенерируем ```ID``` и сохраним итератор на конец
нужного списка
в ```std::unordered_map```(хэш-таблице). Отдаем пользователю ```ID```.

Поиск в ```std::map``` работаеет за ```O(logN)```. Остальные операции
за ```O(1)```.
Именно поэтому время доступа к заявке ```O(logN)```.

## Взаимодействие со стаканом:

Дальнейшее взаимодействие с заявкой осуществляется через ```ID```.

### Основные операции:

```cpp
UnlimitedOrderBook ob; // Конструирование стакана.
OrderId id = ob.Insert(Order{ // Добавление заявки.
	.type=Order::Type::ASK,
	.price=2000,
	.amount=100,
})
ob.Update(id, Order{ // Вторым параметром передается измененная заявка.
	.type=Order::Type::BID,
	.price=100,
	.amount=10,
});

const Order& o = ob.Get(id); // Получение заказа по Id.

ob.Erase(id); // Удаление заявки из стакана.

for (const auto& order : ob.Top()) // Получение лучших 10 заявок.
{
	std::cout << order << std::endl; 
}

const auto& asks = ob.Asks(); // Получить таблицу всех ask-заявок.
const auto& bids = ob.Bids(); // Получить таблицу всех bid-заявок.
```

* Класс ```UnlimitedOrderBook``` является некопируемым.

* Класс ```UnlimitedOrderBook``` не потокобезопасен.

# Альтернативное решение. Задача 3 (LimitedOrderBook)

Мы можем хранить заявки в виде двух векторов пар ```[заявка, id]```,
отсортированных по цене заявки. Использование таких пар обусловлено
необходимостью идентифицировать заявки в стакане.

В одном векторе храним ```Ask```-и, в другом ```Bid```-ы. При добавлении заявки,
кидаем ее в соответствующий вектор и сортируем его нужным образом.

Помимо этого, для повышения производительности, стоит запомнить в каком
конкретно векторе хранится заявка. Для этого
заведем ```std::unordered_map<OrderId, Order::Type>```(хэш-таблицу), с помощью
которой будем ускорять поиск.

Поиск заявки в векторе осуществляется линейным поиском.

Данная реализация более дружелюбна к кэшу процессора, так как использует
массивы.

```LimitedOrderBook``` реализует интерфейс ```IOrderBook``` и может быть
использована как альтернатива ```OrderBook```.

