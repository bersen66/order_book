# OrderBook

Биржевой стакан реализован в виде класса. Сам класс является частью библиотеки.
Это сделано для упрощения тестирования и сопровождения.
В качестве системы сборки используется ```CMake```.

## Пояснение структуры библиотеки:

Заголовочные файлы (```.hpp```), используемые пользователями, вынесены в
папку ```include``` (все то, что подключает пользователь).
Внутренние заголовочные файлы, недоступные пользователю, и ```.cpp``` файлы
содержатся в папке ```src```.

## Решение задачи:

Класс биржевого стакана должен уметь быстро обрабатывать ряд запросов, а именно:

* Добавление новой заявки
* Удаление заявки (удалена может быть любая заявка)
* Изменение имеющейся заявки (изменена может быть любая заявка)
* Вывод 10-ти лучших заявок.

Заявка представляет собой структуру, содержащую информацию о:

* Цене
* Объеме
* Типе (Bid/Ask)

### Обоснование структуры стакана:

Так как нам нужно поддерживать динамические и частые изменения содержимого
стакана
, то необходимо использовать структуры данных, позволяющие быстро удалять, и
изменять содержащиеся в них произвольные элементы.

Подобными свойствами обладают контейнеры:

* ```std::map``` - O(logN)
* ```std::list``` - O(1)
* ```std::set``` - O(logN)
* ```std::unordered_map``` - амортизированная O(1)
* ```std::unordered_set``` - амортизированная O(1)

Существует два вида заявок: ```Bid``` и ```Ask```. Биржевой стакан позволяет
балансировать спрос и предложение.

Исходя из структуры заявки мы можем менять любое ее поле. При изменении цены или
типа, заявка меняет свое положение в стакане.

Будем хранить заявки в ```std::map```, отсортированными по цене (цена заявки -
ключ), согласно типу.
```Bid```-заявки сортируем по убыванию. ```Ask```- по возрастанию.
Значением словаря будет ```std::list```, содержащий заявки.
Выбор ```std::list``` обусловлен необходимостью удаления произвольных элементов.
Мы не можем использовать контейнер ```std::vector```, так как удаление из
середины повлечет
за собой перемещение элементов, а добавление новых элементов вызовет инвалидацию
итераторов.
Связный список нам подходит лучше.

## Обеспечим доступ к заявкам в стакане за O(logN):

При добавлении заявки определим нужный ей словарь. Добавим заявку в конец списка
для конкретной цены. А затем, сгенерируем ```ID``` и сохраним итератор на конец
нужного списка
в ```std::unordered_map```(хэш-таблице). Отдаем пользователю ```ID```.

Поиск в ```std::map``` работаеет за ```O(logN)```. Остальные операции за ```O(1)```.
Именно поэтому время доступа к заявке ```O(logN)```.

## Взаимодействие со стаканом:

Дальнейшее взаимодействие с заявкой осуществляется через ```ID```. 

### Основные операции:
```cpp
OrderBook ob; // Конструирование стакана.
OrderId id = ob.Insert(Order{ // Добавление заявки.
	.type=Order::Type::ASK,
	.price=2000,
	.amount=100,
})
ob.Update(id, Order{ // Вторым параметром передается измененная заявка.
	.type=Order::Type::BID,
	.price=100,
	.amount=10,
});

const Order& o = ob.Get(id); // Получение заказа по Id.

ob.Erase(id); // Удаление заявки из стакана.

for (const auto& order : ob.Top()) // Получение лучших 10 заявок.
{
	std::cout << order << std::endl; 
}

const auto& asks = ob.Asks(); // Получить таблицу всех ask-заявок.
const auto& bids = ob.Bids(); // Получить таблицу всех bid-заявок.
```

Класс ```OrderBook``` является некопируемым.
